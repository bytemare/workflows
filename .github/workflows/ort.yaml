#
# SPDX-License-Identifier: MIT
#
# Copyright (C) 2026 Daniel Bourdrez. All Rights Reserved.
#
# This source code is licensed under the MIT license found in the
# LICENSE file in the root directory of this source tree or at
# https://spdx.org/licenses/MIT.html
#

---

name: OSS Review Toolkit (ORT)

permissions: {}

on:
  workflow_call:
    inputs:
      ort_config_repository:
        description: "Optional ORT config repo (global policy, rules)"
        required: false
        type: string
        default: "https://github.com/oss-review-toolkit/ort-config"
      ort_config_revision:
        description: "Optional ref/commit for ORT config repo"
        required: false
        type: string
        default: "34c5d317e44e86505d0d257f2c1076deda35d9df"
      ort_config_source:
        description: "Source path for ORT config files (relative to workspace, or absolute. Job fails if provided and missing)"
        required: false
        type: string
        default: ""
      ort_config_target:
        description: "Target directory for ORT config files (supports ~ for HOME. Must not exist)"
        required: false
        type: string
        default: "~/.ort/config"
      ort_fail_on:
        description: "Fail-on mode for ORT (violations|issues|never)"
        required: false
        type: string
        default: "violations"
      ort_cli_args:
        description: "Optional extra ORT CLI args (e.g. -P flags)"
        required: false
        type: string
        default: ""

jobs:
  ort:
    name: OSS Review Toolkit (ORT)
    runs-on: ubuntu-latest
    permissions:
      contents: read
      actions: read
    steps:
      - name: Harden Runner
        uses: step-security/harden-runner@20cf305ff2072d973412fa9b1e3a4f227bda3c76
        with:
          disable-sudo: true
          egress-policy: block
          allowed-endpoints: >
            ghcr.io:443
            github.com:443
            hosted-compute-watchdog-prod-eus-01.githubapp.com:443
            pkg-containers.githubusercontent.com:443

      - uses: actions/checkout@0c366fd6a839edf440554fa01a7085ccba70ac98

      # - We stage config into the path ORT expects (by default ~/.ort/config).
      - name: Stage ORT config
        id: stage_ort_config
        shell: bash
        env:
          ORT_CONFIG_SOURCE: ${{ inputs.ort_config_source }}
          ORT_CONFIG_TARGET: ${{ inputs.ort_config_target }}
          ORT_CONFIG_REPO: ${{ inputs.ort_config_repository }}
          ORT_CONFIG_REVISION: ${{ inputs.ort_config_revision }}
          WORKSPACE: ${{ github.workspace }}
        run: |
          set -euo pipefail
          IFS=$'\n\t'
          SOURCE_RAW="$ORT_CONFIG_SOURCE"
          TARGET_RAW="$ORT_CONFIG_TARGET"
          REPO_RAW="$ORT_CONFIG_REPO"
          REV_RAW="$ORT_CONFIG_REVISION"
          WORKSPACE_PATH="${WORKSPACE:-$PWD}"
          HOME_PATH="${HOME:-$WORKSPACE_PATH}"
          output_lines=()

          reject_control_chars() {
            local value="$1"
            local label="$2"
            if [[ "$value" == *$'\n'* || "$value" == *$'\r'* ]]; then
              echo "::error::${label} contains a newline, which is not allowed."
              exit 1
            fi
          }

          resolve_path() {
            local p="$1"
            if [[ $p == \~ ]]; then
              printf '%s\n' "$HOME_PATH"
              return 0
            fi
            if [[ $p == \~/* ]]; then
              printf '%s\n' "$HOME_PATH/${p#\~/}"
              return 0
            fi
            if [[ $p == \~* ]]; then
              echo "::error::Only '~' or '~/' are supported in ORT config paths: $p"
              exit 1
            fi
            if [[ "$p" == /* ]]; then
              printf '%s\n' "$p"
              return 0
            fi
            printf '%s\n' "$WORKSPACE_PATH/$p"
          }

          if [[ -z "$TARGET_RAW" ]]; then
            echo "Skipping ORT config staging because ort_config_target is empty."
            output_lines+=("target=")
          else
            if [[ -n "$SOURCE_RAW" ]]; then
              reject_control_chars "$SOURCE_RAW" "ort_config_source"
            fi
            reject_control_chars "$TARGET_RAW" "ort_config_target"
            if [[ -n "$REPO_RAW" ]]; then
              reject_control_chars "$REPO_RAW" "ort_config_repository"
            fi
            if [[ -n "$REV_RAW" ]]; then
              reject_control_chars "$REV_RAW" "ort_config_revision"
            fi

            TARGET="$(resolve_path "$TARGET_RAW")"

            if [[ -e "$TARGET" ]]; then
              echo "::error::ORT config target already exists. Refusing to overwrite: $TARGET"
              exit 1
            fi

            if [[ -n "$REPO_RAW" ]]; then
              if [[ -n "$REV_RAW" ]]; then
                git init -q "$TARGET"
                git -C "$TARGET" remote add origin "$REPO_RAW"
                git -C "$TARGET" fetch -q --depth 1 origin "$REV_RAW"
                git -C "$TARGET" checkout -q FETCH_HEAD
              else
                git clone -q --depth 1 -- "$REPO_RAW" "$TARGET"
              fi
            else
              mkdir -p -- "$TARGET"
            fi

            if [[ -n "$SOURCE_RAW" ]]; then
              SOURCE="$(resolve_path "$SOURCE_RAW")"
              if [[ -d "$SOURCE" ]]; then
                echo "Staging ORT config overlay from '$SOURCE' to '$TARGET'."
                cp -a -- "$SOURCE"/. "$TARGET"/
          
                # Copy .ort.yml to root, if it exists
                if [[ -f "$SOURCE/.ort.yml" ]]; then
                  echo "Also copying .ort.yml to root workspace."
                  cp -f "$SOURCE/.ort.yml" "${{ github.workspace }}/.ort.yml"
                fi
              else
                echo "::error::ORT config source path does not exist or is not a directory: $SOURCE"
                exit 1
              fi
            else
              echo "ORT config source not provided; continuing without overlay."
            fi

            output_lines+=("target=$TARGET")
            echo "Staged ORT config for action at '$TARGET'."
          fi

          printf '%s\n' "${output_lines[@]}" >> "$GITHUB_OUTPUT"

      - name: Run ORT
        id: ort_run
        continue-on-error: true # allowed to fail so we can still summarize and annotate findings
        env:
          ORT_CONFIG_VCS_URL: ${{ inputs.ort_config_repository }}
          ORT_CONFIG_VCS_REVISION: ${{ inputs.ort_config_revision }}
        uses: oss-review-toolkit/ort-ci-github-action@3a5037ba7b646cc7665bc669410234d126da4723
        with:
          log-level: 'debug'
          # Fail on policy violations (configurable in ORT config)
          fail-on: ${{ inputs.ort_fail_on }}
          # Run full pipeline
          run: cache-dependencies,analyzer,scanner,evaluator,reporter,upload-results
          # Extra CLI args
          ort-cli-args: ${{ inputs.ort_cli_args }}
          ort-config-path: ${{ steps.stage_ort_config.outputs.target }}

      - name: Fail if ORT run failed
        # ORT runs with continue-on-error so we can emit summaries/annotations first.
        # This step restores failure status for the job when ORT failed.
        if: ${{ always() && steps.ort_run.outcome == 'failure' }}
        shell: bash
        run: |
          echo "::error:: ORT reported violations/issues as per the configured fail-on mode. Check the job annotations for details."
          exit 1

      # Use the local action in this repo so PRs can test changes before a release.
      - name: Compiling report and posting results (if in bytemare/workflows)
        if: ${{ github.repository == 'bytemare/workflows' }}
        uses: ./.github/actions/ort-report
        with:
          artifact_dir: ${{ github.workspace }}/.ort/results
          ort_failed: ${{ steps.ort_run.outcome == 'failure' }}

      # Use a pinned version for third-party consumers
      - name: Compiling report and posting results
        if: ${{ github.repository != 'bytemare/workflows' }}
        uses: bytemare/workflows/.github/actions/ort-report@1466ba17a1610d9b1c1bad52ba6eb19cbbfd6ebd
        with:
          artifact_dir: ${{ github.workspace }}/.ort/results
          ort_failed: ${{ steps.ort_run.outcome == 'failure' }}
