#
# SPDX-License-Identifier: MIT
#
# Copyright (C) 2025 Daniel Bourdrez. All Rights Reserved.
#
# This source code is licensed under the MIT license found in the
# LICENSE file in the root directory of this source tree or at
# https://spdx.org/licenses/MIT.html
#

---

name: License and Dependency Compliance Check

on:
  workflow_call:
    inputs:
      # Dependency Review
      allow_spdx:
        description: "Comma-separated SPDX allow-list"
        required: false
        type: string
        default: "MIT,Apache-2.0,BSD-2-Clause,BSD-3-Clause,ISC,Unlicense,CC0-1.0"
      warn_only:
        description: "Report but do not fail PRs"
        required: false
        type: boolean
        default: false
      use_pr_comment:
        description: "Post summary comment on PR (requires pull-requests: write)"
        required: false
        type: boolean
        default: false
      run_component_detection:
        description: "Populate Dependency Graph on PR SHAs (recommended)"
        required: false
        type: boolean
        default: true

      # ORT + ScanCode (High-assurance mode)
      assurance:
        description: "low | standard | high (runs ORT when 'high' or on v* tags)"
        required: false
        type: string
        default: "standard"
      ort_config_repository:
        description: "Optional ORT config repo (global policy, rules)"
        required: false
        type: string
        default: "https://github.com/oss-review-toolkit/ort-config"
      ort_config_revision:
        description: "Optional ref/commit for ORT config repo"
        required: false
        type: string
        default: "34c5d317e44e86505d0d257f2c1076deda35d9df"
      ort_config_source:
        description: "Source path for ORT config files (relative to workspace, or absolute. Job fails if provided and missing)"
        required: false
        type: string
        default: ""
      ort_config_target:
        description: "Target directory for ORT config files (supports ~ for HOME. Must not exist)"
        required: false
        type: string
        default: "~/.ort/config"
      ort_fail_on:
        description: "Fail-on mode for ORT (violations|issues|never)"
        required: false
        type: string
        default: "violations"
      ort_cli_args:
        description: "Optional extra ORT CLI args (e.g. -P flags)"
        required: false
        type: string
        default: ""
      ort_yml_path:
        description: "Optional ORT .yml configuration file path"
        required: false
        type: string
        default: ""

permissions: {}

jobs:
  # Populate Dependency Graph
  component-detection:
    name: Component Detection (Dependency Graph Population)
    if: ${{ inputs.run_component_detection && github.event_name == 'pull_request' }}
    runs-on: ubuntu-latest
    permissions:
      contents: write   # GitHub Dependency Submission API requirement to submit dependencies to the graph - safe: job-scoped, PR-only, official GH action
      id-token: write   # required by the action (OIDC)
    steps:
      - uses: actions/checkout@0c366fd6a839edf440554fa01a7085ccba70ac98
      - name: Component Detection (Dependency Submission)
        uses: advanced-security/component-detection-dependency-submission-action@386aa5c15429f99d6257060dfbaa057da1e71a43

  # Fast Dependency Review
  dependency-review:
    name: Dependency Review
    needs: [component-detection]
    if: ${{ github.event_name == 'pull_request' }}
    runs-on: ubuntu-latest
    permissions:
      contents: read
      pull-requests: write   # needed only when posting the summary
    steps:
      - uses: actions/checkout@0c366fd6a839edf440554fa01a7085ccba70ac98

      # If a repo config exists, use it, else use inline defaults
      - name: Dependency Review (repo config)
        id: review_cfg
        if: ${{ hashFiles('.github/dependency-review-config.yml') != '' }}
        uses: actions/dependency-review-action@98884d411b0f1c583e5ee579e7e897d4623019c2
        with:
          config-file: .github/dependency-review-config.yml
          comment-summary-in-pr: ${{ inputs.use_pr_comment && 'on-failure' || 'never' }}

      - name: Dependency Review (inline defaults)
        if: ${{ steps.review_cfg.outcome == '' }}
        uses: actions/dependency-review-action@98884d411b0f1c583e5ee579e7e897d4623019c2
        with:
          allow-licenses: ${{ inputs.allow_spdx }}
          warn-only: ${{ inputs.warn_only }}
          comment-summary-in-pr: ${{ inputs.use_pr_comment && 'on-failure' || 'never' }}

  # High-assurance: ORT end-to-end (Analyzer→Scanner→Evaluator→Reporter)
  ort-high-assurance:
    name: ORT License Compliance (High Assurance)
    if: ${{ (inputs.assurance == 'high' || (github.ref_type == 'tag' && startsWith(github.ref_name, 'v'))) }}
    runs-on: ubuntu-latest
    permissions:
      contents: read
      actions: read
    steps:
      - uses: actions/checkout@0c366fd6a839edf440554fa01a7085ccba70ac98

      # ORT + ScanCode
      - name: Stage ORT config
        id: stage_ort_config
        shell: bash
        env:
          ORT_CONFIG_SOURCE: ${{ inputs.ort_config_source }}
          ORT_CONFIG_TARGET: ${{ inputs.ort_config_target }}
          ORT_CONFIG_REPO: ${{ inputs.ort_config_repository }}
          ORT_CONFIG_REVISION: ${{ inputs.ort_config_revision }}
          WORKSPACE: ${{ github.workspace }}
        run: |
          set -euo pipefail
          IFS=$'\n\t'
          SOURCE_RAW="$ORT_CONFIG_SOURCE"
          TARGET_RAW="$ORT_CONFIG_TARGET"
          REPO_RAW="$ORT_CONFIG_REPO"
          REV_RAW="$ORT_CONFIG_REVISION"
          WORKSPACE_PATH="${WORKSPACE:-$PWD}"
          HOME_PATH="${HOME:-$WORKSPACE_PATH}"
          output_lines=()

          reject_control_chars() {
            local value="$1"
            local label="$2"
            if [[ "$value" == *$'\n'* || "$value" == *$'\r'* ]]; then
              echo "::error::${label} contains a newline, which is not allowed."
              exit 1
            fi
          }

          resolve_path() {
            local p="$1"
            if [[ $p == \~ ]]; then
              printf '%s\n' "$HOME_PATH"
              return 0
            fi
            if [[ $p == \~/* ]]; then
              printf '%s\n' "$HOME_PATH/${p#\~/}"
              return 0
            fi
            if [[ $p == \~* ]]; then
              echo "::error::Only '~' or '~/' are supported in ORT config paths: $p"
              exit 1
            fi
            if [[ "$p" == /* ]]; then
              printf '%s\n' "$p"
              return 0
            fi
            printf '%s\n' "$WORKSPACE_PATH/$p"
          }

          if [[ -z "$TARGET_RAW" ]]; then
            echo "Skipping ORT config staging because ort_config_target is empty."
            output_lines+=("target=")
          else
            if [[ -n "$SOURCE_RAW" ]]; then
              reject_control_chars "$SOURCE_RAW" "ort_config_source"
            fi
            reject_control_chars "$TARGET_RAW" "ort_config_target"
            if [[ -n "$REPO_RAW" ]]; then
              reject_control_chars "$REPO_RAW" "ort_config_repository"
            fi
            if [[ -n "$REV_RAW" ]]; then
              reject_control_chars "$REV_RAW" "ort_config_revision"
            fi

            TARGET="$(resolve_path "$TARGET_RAW")"

            if [[ -e "$TARGET" ]]; then
              echo "::error::ORT config target already exists. Refusing to overwrite: $TARGET"
              exit 1
            fi

            if [[ -n "$REPO_RAW" ]]; then
              if [[ -n "$REV_RAW" ]]; then
                git init -q "$TARGET"
                git -C "$TARGET" remote add origin "$REPO_RAW"
                git -C "$TARGET" fetch -q --depth 1 origin "$REV_RAW"
                git -C "$TARGET" checkout -q FETCH_HEAD
              else
                git clone -q --depth 1 -- "$REPO_RAW" "$TARGET"
              fi
            else
              mkdir -p -- "$TARGET"
            fi

            if [[ -n "$SOURCE_RAW" ]]; then
              SOURCE="$(resolve_path "$SOURCE_RAW")"
              if [[ -d "$SOURCE" ]]; then
                echo "Staging ORT config overlay from '$SOURCE' to '$TARGET'."
                cp -a -- "$SOURCE"/. "$TARGET"/
              else
                echo "::error::ORT config source path does not exist or is not a directory: $SOURCE"
                exit 1
              fi
            else
              echo "ORT config source not provided; continuing without overlay."
            fi

            output_lines+=("target=$TARGET")
            echo "Staged ORT config for action at '$TARGET'."
          fi

          printf '%s\n' "${output_lines[@]}" >> "$GITHUB_OUTPUT"

      - name: Verify ORT resolutions staging
        if: ${{ steps.stage_ort_config.outputs.target != '' }}
        shell: bash
        env:
          ORT_CONFIG_PATH: ${{ steps.stage_ort_config.outputs.target }}
          ORT_CONFIG_SOURCE: ${{ inputs.ort_config_source }}
          WORKSPACE: ${{ github.workspace }}
        run: |
          set -euo pipefail
          SOURCE_RAW="${ORT_CONFIG_SOURCE:-}"
          WORKSPACE_PATH="${WORKSPACE:-$PWD}"
          HOME_PATH="${HOME:-$WORKSPACE_PATH}"

          resolve_path() {
            local p="$1"
            if [[ $p == \~ ]]; then
              printf '%s\n' "$HOME_PATH"
              return 0
            fi
            if [[ $p == \~/* ]]; then
              printf '%s\n' "$HOME_PATH/${p#\~/}"
              return 0
            fi
            if [[ $p == \~* ]]; then
              echo "::error::Only '~' or '~/' are supported in ORT config paths: $p"
              exit 1
            fi
            if [[ "$p" == /* ]]; then
              printf '%s\n' "$p"
              return 0
            fi
            printf '%s\n' "$WORKSPACE_PATH/$p"
          }

          if [ ! -d "${ORT_CONFIG_PATH}" ]; then
            echo "::error::ORT config path does not exist: ${ORT_CONFIG_PATH}"
            exit 1
          fi
          if [ ! -f "${ORT_CONFIG_PATH}/resolutions.yml" ]; then
            echo "::error::ORT resolutions.yml not found at: ${ORT_CONFIG_PATH}/resolutions.yml"
            exit 1
          fi
          echo "ORT config files staged in: ${ORT_CONFIG_PATH}"
          ls -la "${ORT_CONFIG_PATH}"
          echo "::group::resolutions.yml (head)"
          sed -n '1,200p' "${ORT_CONFIG_PATH}/resolutions.yml"
          echo "::endgroup::"

          if [ -z "${SOURCE_RAW}" ]; then
            echo "ORT config source not provided; overlay check skipped."
            exit 0
          fi

          SOURCE_PATH="$(resolve_path "${SOURCE_RAW}")"
          if [ ! -d "${SOURCE_PATH}" ]; then
            echo "::error::ORT config source path does not exist or is not a directory: ${SOURCE_PATH}"
            exit 1
          fi

          if [ -f "${SOURCE_PATH}/resolutions.yml" ]; then
            if ! cmp -s -- "${SOURCE_PATH}/resolutions.yml" "${ORT_CONFIG_PATH}/resolutions.yml"; then
              echo "::error::ORT resolutions.yml from source was not applied to target."
              echo "::group::source resolutions.yml (head)"
              sed -n '1,200p' "${SOURCE_PATH}/resolutions.yml"
              echo "::endgroup::"
              exit 1
            fi
            echo "Verified: source resolutions.yml matches target."
          else
            echo "ORT config source has no resolutions.yml; overlay check skipped."
          fi

      - name: Run ORT (policy-driven)
        id: ort_run
        continue-on-error: true
        env:
          ORT_CONFIG_VCS_URL: ${{ inputs.ort_config_repository }}
          ORT_CONFIG_VCS_REVISION: ${{ inputs.ort_config_revision }}
        uses: oss-review-toolkit/ort-ci-github-action@3a5037ba7b646cc7665bc669410234d126da4723
        with:
          # Fail on policy violations (configurable in ORT config)
          fail-on: ${{ inputs.ort_fail_on }}
          # Run full pipeline
          run: cache-dependencies,analyzer,scanner,evaluator,reporter,upload-results
          # Extra CLI args
          ort-cli-args: ${{ inputs.ort_cli_args }}
          ort-yml-path: ${{ inputs.ort_yml_path }}
          ort-config-path: ${{ steps.stage_ort_config.outputs.target }}

      - name: Download ORT artifacts
        uses: actions/download-artifact@37930b1c2abaa49bbe596cd826c3c89aef350131
        with:
          path: ort-artifacts
          merge-multiple: true

      - name: Locate ORT evaluation result
        id: find-eval
        if: ${{ always() }}
        shell: bash
        run: |
          set -euo pipefail
          ART_DIR="ort-artifacts"
          eval_path=""
          if [ -d "${ART_DIR}" ]; then
            eval_path="$(find "${ART_DIR}" -type f -name '*evaluation-result*.json' -print | head -n1 || true)"
            if [ -z "${eval_path}" ]; then
              eval_path="$(find "${ART_DIR}" -type f -name '*evaluated-model*.json' -print | head -n1 || true)"
            fi
          fi
          if [ -z "${eval_path}" ]; then
            for candidate in \
              "$HOME/.ort/ort-results/evaluation-result.json" \
              "$HOME/.ort/ort-results/evaluated-model.json" \
              "/home/ort/.ort/ort-results/evaluation-result.json" \
              "/home/ort/.ort/ort-results/evaluated-model.json"; do
              if [ -f "${candidate}" ]; then
                eval_path="${candidate}"
                break
              fi
            done
          fi
          if [ -z "${eval_path}" ]; then
            eval_path="$(find "$HOME" "/home/ort" -maxdepth 6 -type f -name 'evaluation-result.json' -print | head -n1 || true)"
          fi
          if [ -z "${eval_path}" ]; then
            echo "::warning::ORT evaluation result not found in artifacts or common ORT paths."
          else
            echo "Using ORT evaluation result at: ${eval_path}"
          fi
          echo "eval_json=${eval_path}" >> "$GITHUB_OUTPUT"

      - name: Summarize ORT rule violations in Job Summary
        if: ${{ always() && steps.find-eval.outputs.eval_json != '' }}
        shell: bash
        env:
          EVAL_JSON: ${{ steps.find-eval.outputs.eval_json }}
        run: |
          set -euo pipefail
          {
            echo "## ORT License Policy Findings"
            echo
            # The structure can vary slightly across ORT versions; this jq pulls common fields robustly.
            rows="$(jq -r '
              def to_list:
                if type == "array" then . else [.] end;
              def clean:
                tostring
                | gsub("\\|"; "¦")
                | gsub("[\\r\\n]+"; " ");
              def license_id($v):
                ((($v.license // "") as $l
                  | if ($l | type) == "object" then ($l.id // "") else $l end)
                | tostring);
              def is_unknown_license($lic):
                ($lic | test("^(LicenseRef-|NOASSERTION$)"; "i"));
              def matches_resolution($v; $r):
                ((($r.rule? // "") | tostring) as $rr | ($rr == "" or ($v.rule // "" | tostring) == $rr))
                and ((($r.pkg? // "") | tostring) as $rp | ($rp == "" or ($v.pkg // "" | tostring) == $rp))
                and ((($r.message? // "") | tostring) as $re
                  | ($re == "" or (($v.message // "") | test($re))));
              . as $root
              | ($root.resolved_configuration?.resolutions?.rule_violations
                  // $root.resolvedConfiguration?.resolutions?.ruleViolations
                  // []) | to_list as $resolutions
              | ($root.evaluator? // $root.evaluation? // $root.evaluatorResult? // empty)
                | (.violations? // .rule_violations? // .ruleViolations? // empty)
                | to_list as $violations
              | if ($violations | length) == 0 then empty
                else
                  $violations[] | . as $v
                  | ($resolutions | map(select(matches_resolution($v; .)))) as $matches
                  | ($matches[0]) as $res
                  | (license_id($v)) as $lic
                  | (is_unknown_license($lic)) as $lic_unknown
                  | {
                      category: (
                        if $res != null then
                          "accepted"
                        elif $lic_unknown then
                          "unknown"
                        elif ($v.message // "") == "" and ($v.rule // "") == "" then
                          "unknown"
                        else
                          "violation"
                        end
                      ),
                      status: (
                        if $res != null then
                          "Accepted"
                        elif $lic_unknown then
                          "Unknown"
                        elif ($v.message // "") == "" and ($v.rule // "") == "" then
                          "Unknown"
                        else
                          "Violation"
                        end
                      ),
                      reason: (
                        if $res != null then
                          (($res.reason // "policy exception")
                            + (if ($res.comment // "") != "" then ": " + ($res.comment // "") else "" end))
                        else
                          ""
                        end
                      ),
                      sev: ($v.severity // $v.level // ""),
                      rule: (if ($v.rule | type) == "object" then ($v.rule.name // $v.rule.id // "") else ($v.rule // "") end),
                      pkg: (if ($v.pkg | type) == "object" then ($v.pkg.id // "") else ($v.pkg // "") end),
                      lic: ($lic | tostring),
                      msg: ($v.message // $v.description // "")
                    }
                  | [
                      .category,
                      (.status | clean),
                      (.reason | clean),
                      (.rule | clean),
                      (.lic | clean),
                      (.pkg | clean),
                      (.sev | clean),
                      (.msg | clean)
                    ]
                  | @tsv
                end
            ' -- "${EVAL_JSON}" 2>/dev/null || true)"

            if [[ -z "${rows}" ]]; then
              echo "Everything looks good — no policy findings were detected."
            else
              echo
          
              print_section() {
                local section="$1"
                local description="$2"
                local key="$3"
                local section_rows
                section_rows="$(printf '%s\n' "${rows}" | awk -F $'\t' -v k="${key}" '$1==k {print "| " $2 " | " $3 " | " $4 " | " $5 " | " $6 " | " $7 " | " $8 " |"}')"
                if [[ -n "${section_rows}" ]]; then
                  echo "### ${section}"
                  echo
                  echo "${description}"
                  echo
                  echo "| Status | Reason | Rule | License | Package/Project | Rule severity | Message |"
                  echo "|---|---|---|---|---|---|---|"
                  printf '%s\n' "${section_rows}" | head -n 50
                  echo
                fi
              }

              print_section "Accepted" "Non-compatible but explicitly accepted by policy" "accepted"
              print_section "Violation" "Non-compatible and not accepted" "violation"
              print_section "Unknown" "Missing or ambiguous data" "unknown"
            fi
          } >> "$GITHUB_STEP_SUMMARY"

      - name: Emit lightweight GitHub annotations
        if: ${{ always() && steps.find-eval.outputs.eval_json != '' }}
        shell: bash
        env:
          EVAL_JSON: ${{ steps.find-eval.outputs.eval_json }}
        run: |
          set -euo pipefail
          jq -r '
            def to_list:
              if type == "array" then . else [.] end;
            def license_id($v):
              ((($v.license // "") as $l
                | if ($l | type) == "object" then ($l.id // "") else $l end)
              | tostring);
            def is_unknown_license($lic):
              ($lic | test("^(LicenseRef-|NOASSERTION$)"; "i"));
            def cmd_escape:
              tostring
              | gsub("%"; "%25")
              | gsub("\\r"; "%0D")
              | gsub("\\n"; "%0A");
            def matches_resolution($v; $r):
              ((($r.rule? // "") | tostring) as $rr | ($rr == "" or ($v.rule // "" | tostring) == $rr))
              and ((($r.pkg? // "") | tostring) as $rp | ($rp == "" or ($v.pkg // "" | tostring) == $rp))
              and ((($r.message? // "") | tostring) as $re
                | ($re == "" or (($v.message // "") | test($re))));
            . as $root
            | ($root.resolved_configuration?.resolutions?.rule_violations
                // $root.resolvedConfiguration?.resolutions?.ruleViolations
                // []) | to_list as $resolutions
            | ($root.evaluator? // $root.evaluation? // $root.evaluatorResult? // empty)
              | (.violations? // .rule_violations? // .ruleViolations? // empty)
              | to_list as $violations
              | if ($violations | length) == 0 then empty
              else $violations[] | . as $v
              | ($resolutions | map(select(matches_resolution($v; .)))) as $matches
              | ($matches[0]) as $res
              | (license_id($v)) as $lic
              | (is_unknown_license($lic)) as $lic_unknown
              | if $res != null then
                  {sev: "NOTICE", msg: ("Accepted: " + ($v.message // "ORT violation") + " (" + ($res.reason // "policy exception") + ") " + ($res.comment // ""))}
                elif $lic_unknown then
                  {sev: "WARNING", msg: ("Unknown license: " + ($v.message // "ORT finding"))}
                elif ($v.message // "") == "" and ($v.rule // "") == "" then
                  {sev: "WARNING", msg: "Unknown ORT finding: missing rule/message fields."}
                else
                  {sev: ($v.severity // "ERROR"), msg: ($v.message // "ORT violation")}
                end
              | .msg |= cmd_escape
              | "::" + (
                  if (.sev|ascii_upcase) == "ERROR" then "error"
                  elif (.sev|ascii_upcase) == "WARNING" then "warning"
                  else "notice"
                  end
                ) + "::" + .msg
              end
          ' -- "${EVAL_JSON}" 2>/dev/null | while IFS= read -r line; do
            echo "$line"
          done

      - name: Emit ORT failure annotation when evaluation is missing
        if: ${{ always() && steps.ort_run.outcome == 'failure' && steps.find-eval.outputs.eval_json == '' }}
        shell: bash
        run: |
          echo "::error::ORT run failed and evaluation-result.json was not found. Check ORT logs for details."

      - name: Fail if ORT run failed
        if: ${{ always() && steps.ort_run.outcome == 'failure' }}
        shell: bash
        run: |
          exit 1
