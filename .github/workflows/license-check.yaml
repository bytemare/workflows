#
# SPDX-License-Identifier: MIT
#
# Copyright (C) 2025 Daniel Bourdrez. All Rights Reserved.
#
# This source code is licensed under the MIT license found in the
# LICENSE file in the root directory of this source tree or at
# https://spdx.org/licenses/MIT.html
#

---

name: License and Dependency Compliance Check

on:
  workflow_call:
    inputs:
      # Dependency Review
      allow_spdx:
        description: "Comma-separated SPDX allow-list"
        required: false
        type: string
        default: "MIT,Apache-2.0,BSD-2-Clause,BSD-3-Clause,ISC,Unlicense,CC0-1.0"
      warn_only:
        description: "Report but do not fail PRs"
        required: false
        type: boolean
        default: false
      use_pr_comment:
        description: "Post summary comment on PR (requires pull-requests: write)"
        required: false
        type: boolean
        default: false
      run_component_detection:
        description: "Populate Dependency Graph on PR SHAs (recommended)"
        required: false
        type: boolean
        default: true

      # ORT + ScanCode (High-assurance mode)
      assurance:
        description: "low | standard | high (runs ORT when 'high' or on v* tags)"
        required: false
        type: string
        default: "standard"
      ort_config_repository:
        description: "Optional ORT config repo (global policy, rules)"
        required: false
        type: string
        default: ""
      ort_config_revision:
        description: "Optional ref/commit for ORT config repo"
        required: false
        type: string
        default: ""
      ort_config_source:
        description: "Source path for ORT config files (relative to workspace, or absolute; job fails if missing)"
        required: false
        type: string
        default: ".github/ort"
      ort_config_target:
        description: "Target directory for ORT config files (supports ~ for HOME; must not exist)"
        required: false
        type: string
        default: "~/.ort/config"
      ort_fail_on:
        description: "Fail-on mode for ORT (violations|issues|never)"
        required: false
        type: string
        default: "violations"
      ort_cli_args:
        description: "Optional extra ORT CLI args (e.g. -P flags)"
        required: false
        type: string
        default: ""

permissions: {}

jobs:
  # Populate Dependency Graph
  component-detection:
    name: Component Detection (Dependency Graph Population)
    if: ${{ inputs.run_component_detection && github.event_name == 'pull_request' }}
    runs-on: ubuntu-latest
    permissions:
      contents: write   # GitHub Dependency Submission API requirement to submit dependencies to the graph - safe: job-scoped, PR-only, official GH action
      id-token: write   # required by the action (OIDC)
    steps:
      - uses: actions/checkout@0c366fd6a839edf440554fa01a7085ccba70ac98
      - name: Component Detection (Dependency Submission)
        uses: advanced-security/component-detection-dependency-submission-action@386aa5c15429f99d6257060dfbaa057da1e71a43

  # Fast Dependency Review
  dependency-review:
    name: Dependency Review
    needs: [component-detection]
    if: ${{ github.event_name == 'pull_request' }}
    runs-on: ubuntu-latest
    permissions:
      contents: read
      pull-requests: write   # needed only when posting the summary
    steps:
      - uses: actions/checkout@0c366fd6a839edf440554fa01a7085ccba70ac98

      # If a repo config exists, use it, else use inline defaults
      - name: Dependency Review (repo config)
        id: review_cfg
        if: ${{ hashFiles('.github/dependency-review-config.yml') != '' }}
        uses: actions/dependency-review-action@98884d411b0f1c583e5ee579e7e897d4623019c2
        with:
          config-file: .github/dependency-review-config.yml
          comment-summary-in-pr: ${{ inputs.use_pr_comment && 'on-failure' || 'never' }}

      - name: Dependency Review (inline defaults)
        if: ${{ steps.review_cfg.outcome == '' }}
        uses: actions/dependency-review-action@98884d411b0f1c583e5ee579e7e897d4623019c2
        with:
          allow-licenses: ${{ inputs.allow_spdx }}
          warn-only: ${{ inputs.warn_only }}
          comment-summary-in-pr: ${{ inputs.use_pr_comment && 'on-failure' || 'never' }}

  # High-assurance: ORT end-to-end (Analyzer→Scanner→Evaluator→Reporter)
  ort-high-assurance:
    name: ORT License Compliance (High Assurance)
    if: ${{ (inputs.assurance == 'high' || (github.ref_type == 'tag' && startsWith(github.ref_name, 'v'))) }}
    runs-on: ubuntu-latest
    permissions:
      contents: read
      actions: read
    steps:
      - uses: actions/checkout@0c366fd6a839edf440554fa01a7085ccba70ac98

      # ORT + ScanCode
      - name: Stage ORT config
        id: stage_ort_config
        shell: bash
        env:
          ORT_CONFIG_SOURCE: ${{ inputs.ort_config_source }}
          ORT_CONFIG_TARGET: ${{ inputs.ort_config_target }}
          WORKSPACE: ${{ github.workspace }}
        run: |
          set -euo pipefail
          IFS=$'\n\t'
          SOURCE_RAW="$ORT_CONFIG_SOURCE"
          TARGET_RAW="$ORT_CONFIG_TARGET"
          WORKSPACE_PATH="${WORKSPACE:-$PWD}"
          HOME_PATH="${HOME:-$WORKSPACE_PATH}"

          reject_control_chars() {
            local value="$1"
            local label="$2"
            if [[ "$value" == *$'\n'* || "$value" == *$'\r'* ]]; then
              echo "::error::${label} contains a newline, which is not allowed."
              exit 1
            fi
          }

          resolve_path() {
            local p="$1"
            if [[ $p == \~ ]]; then
              printf '%s\n' "$HOME_PATH"
              return 0
            fi
            if [[ $p == \~/* ]]; then
              printf '%s\n' "$HOME_PATH/${p#\~/}"
              return 0
            fi
            if [[ $p == \~* ]]; then
              echo "::error::Only '~' or '~/' are supported in ORT config paths: $p"
              exit 1
            fi
            if [[ "$p" == /* ]]; then
              printf '%s\n' "$p"
              return 0
            fi
            printf '%s\n' "$WORKSPACE_PATH/$p"
          }

          rel_to_workspace() {
            local p="$1"
            if [[ "$p" == "$WORKSPACE_PATH" ]]; then
              printf '%s\n' "."
              return 0
            fi
            if [[ "$p" == "$WORKSPACE_PATH/"* ]]; then
              printf '%s\n' "${p#"$WORKSPACE_PATH"/}"
              return 0
            fi
            printf '%s\n' "$p"
          }

          if [[ -z "$SOURCE_RAW" || -z "$TARGET_RAW" ]]; then
            echo "Skipping ORT config staging because ort_config_source or ort_config_target is empty."
            echo "target=" >> "$GITHUB_OUTPUT"
            echo "source_for_ort=" >> "$GITHUB_OUTPUT"
            echo "target_for_ort=" >> "$GITHUB_OUTPUT"
            exit 0
          fi

          reject_control_chars "$SOURCE_RAW" "ort_config_source"
          reject_control_chars "$TARGET_RAW" "ort_config_target"

          SOURCE="$(resolve_path "$SOURCE_RAW")"
          TARGET="$(resolve_path "$TARGET_RAW")"
          SOURCE_FOR_ORT="$(rel_to_workspace "$SOURCE")"
          TARGET_FOR_ORT="$(rel_to_workspace "$TARGET")"

          if [[ ! -d "$SOURCE" ]]; then
            echo "::error::ORT config source path does not exist or is not a directory: $SOURCE"
            exit 1
          fi
          if [[ ! -f "$SOURCE/config.yml" ]]; then
            echo "::error::ORT config source is missing config.yml: $SOURCE/config.yml"
            exit 1
          fi

          if [[ -e "$TARGET" ]]; then
            echo "::error::ORT config target already exists. Refusing to overwrite: $TARGET"
            exit 1
          fi

          echo "Staging ORT config from '$SOURCE' to '$TARGET'."
          mkdir -p -- "$TARGET"
          cp -a -- "$SOURCE"/. "$TARGET"/
          if [[ ! -f "$TARGET/config.yml" ]]; then
            echo "::error::ORT config target is missing config.yml after copy: $TARGET/config.yml"
            exit 1
          fi
          echo "target=$TARGET" >> "$GITHUB_OUTPUT"
          echo "source_for_ort=$SOURCE_FOR_ORT" >> "$GITHUB_OUTPUT"
          echo "target_for_ort=$TARGET_FOR_ORT" >> "$GITHUB_OUTPUT"
          echo "Staged ORT config for action from '$SOURCE_FOR_ORT'."

      - name: Run ORT (policy-driven)
        env:
          ORT_CONFIG_VCS_URL: ${{ inputs.ort_config_repository }}
          ORT_CONFIG_VCS_REVISION: ${{ inputs.ort_config_revision }}
        uses: oss-review-toolkit/ort-ci-github-action@3a5037ba7b646cc7665bc669410234d126da4723
        with:
          # Fail on policy violations (configurable in ORT config)
          fail-on: ${{ inputs.ort_fail_on }}
          # Run full pipeline
          run: cache-dependencies,analyzer,scanner,evaluator,reporter,upload-results
          # Extra CLI args
          ort-cli-args: ${{ inputs.ort_cli_args }}
          ort-config-path: ${{ steps.stage_ort_config.outputs.source_for_ort }}

      - name: Download ORT artifacts
        uses: actions/download-artifact@37930b1c2abaa49bbe596cd826c3c89aef350131
        with:
          path: ort-artifacts
          merge-multiple: true

      - name: Locate ORT evaluation result
        id: find-eval
        if: ${{ always() }}
        shell: bash
        run: |
          set -euo pipefail
          ART_DIR="ort-artifacts"
          eval_path=""
          if [ -d "${ART_DIR}" ]; then
            eval_path="$(find "${ART_DIR}" -type f \( -name '*evaluation-result*.json' -o -name '*evaluated-model*.json' \) -print | head -n1 || true)"
          fi
          echo "eval_json=${eval_path}" >> "$GITHUB_OUTPUT"

      - name: Summarize ORT rule violations in Job Summary
        if: ${{ always() && steps.find-eval.outputs.eval_json != '' }}
        shell: bash
        env:
          EVAL_JSON: ${{ steps.find-eval.outputs.eval_json }}
        run: |
          set -euo pipefail
          {
            echo "## ORT rule violations (top 50)"
            echo
            echo "| Severity | Rule | Package/Project | License | Message |"
            echo "|---|---|---|---|---|"
            # The structure can vary slightly across ORT versions; this jq pulls common fields robustly.
            jq -r '
              .. | objects
              | select(has("violations") or has("rule_violations") or has("ruleViolations"))
              | (.violations // .rule_violations // .ruleViolations)
              | .[]
              | {
                  sev: (.severity // .level // ""),
                  rule: (.rule?.name // .rule?.id // .rule // ""),
                  pkg: (.pkg?.id // .package?.id // .project?.id // .id // ""),
                  lic: (.license?.id // .license // .licenseFinding?.license // ""),
                  msg: (.message // .description // "")
                }
              | "\(.sev)|\(.rule)|\(.pkg)|\(.lic)|\(.msg)"
            ' -- "${EVAL_JSON}" \
            | head -n 50 \
            | sed 's/|/ | /g' \
            | sed 's/^/| /; s/$/ |/'
            echo
            echo "_Full evidence remains in the artifact Web App if you need deep dive._"
          } >> "$GITHUB_STEP_SUMMARY"

      - name: Emit lightweight GitHub annotations
        if: ${{ always() && steps.find-eval.outputs.eval_json != '' }}
        shell: bash
        env:
          EVAL_JSON: ${{ steps.find-eval.outputs.eval_json }}
        run: |
          set -euo pipefail
          jq -r '
            .. | objects
            | select(has("violations") or has("rule_violations") or has("ruleViolations"))
            | (.violations // .rule_violations // .ruleViolations)
            | .[]
            | {sev: (.severity // "ERROR"), msg: (.message // "ORT violation")}
            | "::" + (if (.sev|ascii_upcase) == "ERROR" then "error" else "warning" end) + "::" + .msg
          ' -- "${EVAL_JSON}" | while IFS= read -r line; do
            echo "$line"
          done
