#
# SPDX-License-Identifier: MIT
#
# Copyright (C) 2026 Daniel Bourdrez. All Rights Reserved.
#
# This source code is licensed under the MIT license found in the
# LICENSE file in the root directory of this source tree or at
# https://spdx.org/licenses/MIT.html
#

---

name: Coverage Suite

permissions: { }

on:
  workflow_call:
    inputs:
      coverage-enabled:
        description: 'Enable shared coverage generation and artifact handoff'
        required: false
        type: boolean
        default: false
      coverage-go-enabled:
        description: 'Generate Go coverage report'
        required: false
        type: boolean
        default: true
      coverage-go-command:
        description: 'Go coverage command. Must produce coverage-go-report-path.'
        required: false
        type: string
        default: 'go test -v -race -covermode=atomic -coverpkg=./... -coverprofile=coverage.out ./...'
      coverage-go-report-path:
        description: 'Go coverage report path produced by coverage-go-command'
        required: false
        type: string
        default: 'coverage.out'
      coverage-python-enabled:
        description: 'Generate Python coverage report'
        required: false
        type: boolean
        default: false
      coverage-python-version:
        description: 'Python version used when generating Python coverage'
        required: false
        type: string
        default: '3.13'
      coverage-python-command:
        description: 'Python coverage command. Must produce coverage-python-report-path.'
        required: false
        type: string
        default: 'pytest --cov=. --cov-report=xml --cov-report=term --quiet'
      coverage-python-report-path:
        description: 'Python coverage report path produced by coverage-python-command'
        required: false
        type: string
        default: 'coverage.xml'
      coverage-artifact-name:
        description: 'Unified artifact name containing coverage reports and manifest'
        required: false
        type: string
        default: 'coverage-report-all'
      coverage-manifest-path:
        description: 'Manifest path inside the unified coverage artifact'
        required: false
        type: string
        default: 'coverage/manifest.json'
    outputs:
      coverage_artifact_name:
        description: 'Coverage artifact name to consume downstream'
        value: ${{ jobs.CoverageBundle.outputs.coverage_artifact_name }}
      coverage_manifest_path:
        description: 'Coverage manifest path to consume downstream'
        value: ${{ jobs.CoverageBundle.outputs.coverage_manifest_path }}

jobs:
  CoverageGo:
    if: ${{ inputs['coverage-enabled'] && inputs['coverage-go-enabled'] }}
    permissions:
      contents: read
    uses: ./.github/workflows/coverage-go.yaml
    with:
      coverage-go-command: ${{ inputs['coverage-go-command'] }}
      coverage-go-report-path: ${{ inputs['coverage-go-report-path'] }}

  CoveragePython:
    if: ${{ inputs['coverage-enabled'] && inputs['coverage-python-enabled'] }}
    permissions:
      contents: read
    uses: ./.github/workflows/coverage-python.yaml
    with:
      coverage-python-version: ${{ inputs['coverage-python-version'] }}
      coverage-python-command: ${{ inputs['coverage-python-command'] }}
      coverage-python-report-path: ${{ inputs['coverage-python-report-path'] }}

  CoverageBundle:
    if: >-
      ${{
        always() &&
        (needs.CoverageGo.result == 'success' || needs.CoverageGo.result == 'skipped') &&
        (needs.CoveragePython.result == 'success' || needs.CoveragePython.result == 'skipped')
      }}
    needs:
      - CoverageGo
      - CoveragePython
    runs-on: ubuntu-latest
    permissions:
      actions: read
      contents: read
    outputs:
      coverage_artifact_name: ${{ steps.set_outputs.outputs.coverage_artifact_name }}
      coverage_manifest_path: ${{ steps.set_outputs.outputs.coverage_manifest_path }}
    steps:
      - name: Harden Runner
        uses: step-security/harden-runner@20cf305ff2072d973412fa9b1e3a4f227bda3c76
        with:
          disable-sudo: true
          egress-policy: block
          allowed-endpoints: >
            api.github.com:443
            github.com:443
            objects.githubusercontent.com:443
            uploads.github.com:443

      - name: Download coverage report artifacts
        if: >-
          ${{
            inputs['coverage-enabled'] &&
            (needs.CoverageGo.result == 'success' || needs.CoveragePython.result == 'success')
          }}
        uses: actions/download-artifact@37930b1c2abaa49bbe596cd826c3c89aef350131
        with:
          pattern: coverage-report-*
          path: .coverage-artifacts
          merge-multiple: false

      - name: Debug coverage file locations
        if: ${{ inputs['coverage-enabled'] }}
        shell: bash
        run: |
          set -euo pipefail
          echo "Downloaded coverage artifacts:"
          find .coverage-artifacts -maxdepth 6 -type f | sort || true
          echo "Canonical coverage files:"
          find coverage -maxdepth 4 -type f | sort || true

      - name: Validate coverage bundle config
        if: ${{ inputs['coverage-enabled'] }}
        shell: bash
        env:
          ARTIFACT_NAME: ${{ inputs['coverage-artifact-name'] }}
          MANIFEST_PATH: ${{ inputs['coverage-manifest-path'] }}
        run: |
          set -euo pipefail
          if [ -z "$ARTIFACT_NAME" ]; then
            echo "coverage-artifact-name must be set when coverage is enabled." >&2
            exit 1
          fi
          if [ -z "$MANIFEST_PATH" ]; then
            echo "coverage-manifest-path must be set when coverage is enabled." >&2
            exit 1
          fi

      - name: Build coverage manifest
        if: ${{ inputs['coverage-enabled'] }}
        shell: bash
        env:
          MANIFEST_PATH: ${{ inputs['coverage-manifest-path'] }}
        run: |
          set -euo pipefail
          python3 - <<'PY'
          import json
          import os
          import pathlib
          import re
          import shutil

          manifest_path = os.environ["MANIFEST_PATH"]
          if pathlib.Path(manifest_path).is_absolute():
              raise SystemExit(f"coverage-manifest-path must be relative, got '{manifest_path}'.")
          if manifest_path.startswith("../") or "/../" in manifest_path:
              raise SystemExit(f"coverage-manifest-path must not escape workspace, got '{manifest_path}'.")
          if not manifest_path.startswith("coverage/"):
              raise SystemExit("coverage-manifest-path must be under the coverage/ directory.")

          artifacts_root = pathlib.Path(".coverage-artifacts")
          if not artifacts_root.is_dir():
              raise SystemExit(
                  "No downloaded coverage artifacts found. Ensure coverage producers uploaded artifacts."
              )

          metadata_files = sorted(artifacts_root.rglob("coverage-metadata.json"))
          if not metadata_files:
              raise SystemExit(
                  "No coverage metadata files were found. Ensure each coverage producer uploads coverage-metadata.json."
              )

          reports = []
          for metadata_file in metadata_files:
              try:
                  data = json.loads(metadata_file.read_text(encoding="utf-8"))
              except json.JSONDecodeError as exc:
                  raise SystemExit(f"Invalid JSON in '{metadata_file}': {exc}") from exc

              producer_reports = data.get("reports")
              if not isinstance(producer_reports, list) or not producer_reports:
                  raise SystemExit(f"Metadata file '{metadata_file}' does not declare any reports.")

              producer_root = metadata_file.parent.resolve()
              for report in producer_reports:
                  if not isinstance(report, dict):
                      raise SystemExit(f"Invalid report entry in '{metadata_file}': {report!r}")

                  language = report.get("language")
                  source = report.get("path")
                  if not isinstance(language, str) or not language.strip():
                      raise SystemExit(f"Report in '{metadata_file}' is missing a language.")
                  if not isinstance(source, str) or not source:
                      raise SystemExit(f"Report in '{metadata_file}' is missing a path.")

                  source_path = pathlib.PurePosixPath(source)
                  if source_path.is_absolute() or ".." in source_path.parts:
                      raise SystemExit(f"Invalid report path '{source}' in '{metadata_file}'.")

                  absolute_source = (producer_root / pathlib.Path(*source_path.parts)).resolve()
                  try:
                      absolute_source.relative_to(producer_root)
                  except ValueError as exc:
                      raise SystemExit(
                          f"Report path '{source}' in '{metadata_file}' escapes the artifact root."
                      ) from exc

                  if not absolute_source.is_file():
                      raise SystemExit(
                          f"Report path '{source}' in '{metadata_file}' does not exist in downloaded artifacts."
                      )

                  include_in_codecov = report.get("codecov", True)
                  if not isinstance(include_in_codecov, bool):
                      raise SystemExit(
                          f"Invalid codecov flag for report '{source}' in '{metadata_file}'."
                      )

                  language_slug = re.sub(r"[^a-z0-9]+", "-", language.lower()).strip("-") or "unknown"
                  destination_dir = pathlib.Path("coverage") / language_slug
                  destination_dir.mkdir(parents=True, exist_ok=True)

                  destination = destination_dir / absolute_source.name
                  stem = destination.stem
                  suffix = destination.suffix
                  duplicate_index = 2
                  while destination.exists():
                      destination = destination_dir / f"{stem}-{duplicate_index}{suffix}"
                      duplicate_index += 1

                  shutil.copy2(absolute_source, destination)

                  entry = {
                      "language": language,
                      "path": destination.as_posix(),
                      "codecov": include_in_codecov,
                  }

                  language_version = report.get("language_version")
                  if language_version is not None:
                      if not isinstance(language_version, str) or not language_version.strip():
                          raise SystemExit(
                              f"Invalid language_version for report '{source}' in '{metadata_file}'."
                          )
                      entry["language_version"] = language_version.strip()

                  sonar_property = report.get("sonar_property")
                  if sonar_property is not None:
                      if not isinstance(sonar_property, str) or not sonar_property:
                          raise SystemExit(
                              f"Invalid sonar_property for report '{source}' in '{metadata_file}'."
                          )
                      entry["sonar_property"] = sonar_property

                  reports.append(entry)

          if not reports:
              raise SystemExit("coverage-enabled is true, but no coverage reports were produced by enabled coverage jobs.")

          payload = {"version": "1", "reports": reports}
          manifest_file = pathlib.Path(manifest_path)
          manifest_file.parent.mkdir(parents=True, exist_ok=True)
          manifest_file.write_text(json.dumps(payload, indent=2, sort_keys=True) + "\n", encoding="utf-8")
          print(f"Wrote manifest to {manifest_path}")
          PY

      - name: Debug bundled coverage files
        if: ${{ inputs['coverage-enabled'] }}
        shell: bash
        run: |
          set -euo pipefail
          echo "Bundled coverage files:"
          find coverage -maxdepth 6 -type f | sort

      - name: Upload bundled coverage artifact
        if: ${{ inputs['coverage-enabled'] }}
        uses: actions/upload-artifact@b7c566a772e6b6bfb58ed0dc250532a479d7789f
        with:
          name: ${{ inputs['coverage-artifact-name'] }}
          path: coverage/
          if-no-files-found: error

      - name: Set coverage outputs
        id: set_outputs
        shell: bash
        env:
          COVERAGE_ENABLED: ${{ inputs['coverage-enabled'] }}
          ARTIFACT_NAME: ${{ inputs['coverage-artifact-name'] }}
          MANIFEST_PATH: ${{ inputs['coverage-manifest-path'] }}
        run: |
          set -euo pipefail
          if [ "$COVERAGE_ENABLED" = "true" ]; then
            echo "coverage_artifact_name=$ARTIFACT_NAME" >> "$GITHUB_OUTPUT"
            echo "coverage_manifest_path=$MANIFEST_PATH" >> "$GITHUB_OUTPUT"
          else
            echo "coverage_artifact_name=" >> "$GITHUB_OUTPUT"
            echo "coverage_manifest_path=" >> "$GITHUB_OUTPUT"
          fi
